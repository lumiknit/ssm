{"metadata":{"name":"ssm-opcodes","version":"0.1.0"},"types":{"u16":{"type":"uint","bytes":2},"u32":{"type":"uint","bytes":4},"i32":{"type":"int","bytes":4},"f32":{"type":"float","bytes":4},"g32":{"type":"global","bytes":4},"o16":{"type":"offset","bytes":2},"o32":{"type":"offset","bytes":4},"b32":{"type":"array","bytes":4,"elem":{"type":"uint","bytes":1}},"j32":{"type":"array","bytes":4,"elem":{"type":"offset","bytes":4}},"m16":{"type":"magic","bytes":2}},"opcodes":[{"name":"NOP","args":[],"desc":"Do Nothing","c_impl":""},{"name":"POP","args":[{"name":"count","type":"u16"}],"desc":"Pop count items from the stack","c_impl":"reg.sp += count;"},{"name":"PUSH","args":[{"name":"off_sp","type":"u16"}],"desc":"Push [sp + off_sp]","c_impl":"ssmV tmp = reg.sp[off_sp];\n*(--reg.sp) = tmp;"},{"name":"PUSHBP","args":[{"name":"off_bp","type":"u16"}],"desc":"Push [bp - off_bp]","c_impl":"ssmV tmp = reg.bp[-off_bp];\n*(--reg.sp) = tmp;"},{"name":"PUSHAP","args":[{"name":"off_ap","type":"u16"}],"desc":"Push [ap + off_ap]","c_impl":"ssmV tmp = BP2AP(reg.bp)[off_ap];\n*(--reg.sp) = tmp;"},{"name":"POPSET","args":[{"name":"off_sp","type":"u16"}],"desc":"Pop and set into [sp + off_sp]","c_impl":"reg.sp[off_sp] = *reg.sp;\nreg.sp++;"},{"name":"PUSHI","args":[{"name":"value","type":"i32"}],"desc":"Push integer literal","c_impl":"*(--reg.sp) = ssmInt2Val(value);"},{"name":"PUSHF","args":[{"name":"value","type":"f32"}],"desc":"Push float literal","c_impl":"*(--reg.sp) = ssmFlt2Val(value);"},{"name":"PUSHFN","args":[{"name":"fn_off","type":"o32"}],"desc":"Create a function at (ip + fn_off) with no captures. Note that (ip + fn_off) must be aligned by 2."},{"name":"PUSHGLOBAL","args":[{"name":"global","type":"g32"}],"desc":"Push index-th global","c_impl":"*(--reg.sp) = vm->mem.global->vals[global];"},{"name":"POPSETGLOBAL","args":[{"name":"global","type":"g32"}],"desc":"Pop and set into index-th global","c_impl":"vm->mem.global->vals[global] = *reg.sp;\nreg.sp++;"},{"name":"PUSHISLONG","args":[{"name":"off","type":"u16"}],"desc":"Check [sp + off] is a long tuple.","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[off]);\nssmV hd = ssmTHd(tup);\n*(--reg.sp) = ssmInt2Val(ssmHdIsLong(hd));"},{"name":"TUP","args":[{"name":"tag","type":"u16"},{"name":"count","type":"u16"}],"desc":"Create a short tuple with tag and count items.","c_impl":"ssmT tup = ssmNewTup(&vm->mem, tag, count);\nmemcpy(&ssmTFirst(tup), reg.sp, count * sizeof(ssmV));\nreg.sp += count;\n*reg.sp = ssmTup2Val(tup);"},{"name":"PUSHTAG","args":[{"name":"off","type":"u16"}],"desc":"Push tag of [sp + off]","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[off]);\n*(--reg.sp) = ssmUint2Val(ssmHdTag(ssmTHd(tup)));"},{"name":"PUSHLEN","args":[{"name":"off","type":"u16"}],"desc":"Push length of [sp + off]","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[off]);\n*(--reg.sp) = ssmUint2Val(ssmHdShortWords(ssmTHd(tup)));"},{"name":"PUSHELEM","args":[{"name":"off","type":"u16"},{"name":"index","type":"u16"}],"desc":"Push index-th element of [sp + off]","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[off]);\n*(--reg.sp) = ssmTElem(tup, index);"},{"name":"LONG","args":[{"name":"bytes","type":"b32"}],"desc":"Create a long tuple with bytes.","c_impl":"ssmT tup = ssmNewLongTup(&vm->mem, bytes_len);\nmemcpy(&ssmTFirst(tup), bytes, bytes_len);\n*(--reg.sp) = ssmTup2Val(tup);"},{"name":"POPSETBYTE","args":[{"name":"off","type":"u16"}],"desc":"Set [sp + off][sp + 1] = [sp], then pop 2 values","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[off]);\nuint8_t byte = (uint8_t)ssmVal2Uint(reg.sp[0]);\nsize_t idx = (size_t)ssmVal2Uint(reg.sp[1]);\nssmTByte(tup, idx) = byte;\nreg.sp += 2;"},{"name":"PUSHLONGLEN","args":[{"name":"off","type":"u16"}],"desc":"Push length of [sp + off]","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[off]);\n*(--reg.sp) = ssmUint2Val(ssmHdLongBytes(ssmTHd(tup)));"},{"name":"PUSHBYTE","args":[{"name":"off","type":"u16"}],"desc":"Set [sp] = [sp + off][sp]","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[off]);\nuint8_t byte = ssmTByte(tup, (size_t)ssmVal2Uint(reg.sp[0]));\nreg.sp[off] = ssmUint2Val(byte);"},{"name":"JOIN","args":[],"desc":"Pop 2 values and push joined value [sp] ++ [sp + 1]","c_impl":"ssmT tup1 = ssmVal2Tup(reg.sp[0]);\nssmT tup2 = ssmVal2Tup(reg.sp[1]);\nsize_t len1 = ssmHdLongBytes(ssmTHd(tup1));\nsize_t len2 = ssmHdLongBytes(ssmTHd(tup2));\nssmT tup = ssmNewLongTup(&vm->mem, len1 + len2);\nmemcpy(&ssmTByte(tup, 0), &ssmTByte(tup1, 0), len1);\nmemcpy(&ssmTByte(tup, len1), &ssmTByte(tup2, 0), len2);\nreg.sp++;\n*reg.sp = ssmTup2Val(tup);"},{"name":"SUBLONG","args":[],"desc":"Pop 3 values and push [sp + 2][[sp] .. [sp + 1]]","c_impl":"ssmT tup = ssmVal2Tup(reg.sp[2]);\nsize_t start = (size_t)ssmVal2Uint(reg.sp[0]);\nsize_t end = (size_t)ssmVal2Uint(reg.sp[1]);\nsize_t len = end - start;\nssmT sub = ssmNewLongTup(&vm->mem, len);\nmemcpy(&ssmTFirst(sub), &ssmTByte(tup, start), len);\nreg.sp += 2;\n*reg.sp = ssmTup2Val(sub);"},{"name":"LONGCMP","args":[],"desc":"Pop 2 values and push [sp] <=> [sp + 1] (-1 if <, 0 if ==, 1 if >)","c_impl":"ssmT tup1 = ssmVal2Tup(reg.sp[0]);\nssmT tup2 = ssmVal2Tup(reg.sp[1]);\nsize_t len1 = ssmHdLongBytes(ssmTHd(tup1));\nsize_t len2 = ssmHdLongBytes(ssmTHd(tup2));\nint cmp = memcmp(&ssmTFirst(tup1), &ssmTFirst(tup2), len1 < len2 ? len1 : len2);\nif (cmp == 0) {\n  cmp = len1 < len2 ? -1 : len1 > len2 ? 1 : 0;\n}\nreg.sp++;\n*reg.sp = ssmInt2Val(cmp);"},{"name":"APP","aligned":"right","args":[{"name":"count","type":"u16"}],"desc":"Repeat applying a closure at [sp] and args [sp + 1 .. sp + count] until all args are consumed. If some args are left, they are packed as a closure."},{"name":"RET","args":[{"name":"off","type":"u16"}],"desc":"Return with the return value [sp + off]"},{"name":"RETAPP","aligned":"right","args":[{"name":"count","type":"u16"}],"desc":"Tailcall. Call and return the value."},{"name":"INTADD","args":[],"desc":"Pop 2 values and push [sp] + [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a + b);"},{"name":"INTSUB","args":[],"desc":"Pop 2 values and push [sp] - [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a - b);"},{"name":"INTMUL","args":[],"desc":"Pop 2 values and push [sp] * [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a * b);"},{"name":"UINTMUL","args":[],"desc":"Pop 2 values and push [sp] * [sp + 1]","c_impl":"ssmUptr a = ssmVal2Uint(reg.sp[0]);\nssmUptr b = ssmVal2Uint(reg.sp[1]);\n*(++reg.sp) = ssmUint2Val(a * b);"},{"name":"INTDIV","args":[],"desc":"Pop 2 values and push [sp] / [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a / b);"},{"name":"UINTDIV","args":[],"desc":"Pop 2 values and push [sp] / [sp + 1]","c_impl":"ssmUptr a = ssmVal2Uint(reg.sp[0]);\nssmUptr b = ssmVal2Uint(reg.sp[1]);\n*(++reg.sp) = ssmUint2Val(a / b);"},{"name":"INTMOD","args":[],"desc":"Pop 2 values and push [sp] % [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a % b);"},{"name":"UINTMOD","args":[],"desc":"Pop 2 values and push [sp] % [sp + 1]","c_impl":"ssmUptr a = ssmVal2Uint(reg.sp[0]);\nssmUptr b = ssmVal2Uint(reg.sp[1]);\n*(++reg.sp) = ssmUint2Val(a % b);"},{"name":"INTUNM","args":[],"desc":"Pop 1 value and push -[sp]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\n*reg.sp = ssmInt2Val(-a);"},{"name":"INTSHL","args":[],"desc":"Pop 2 values and push [sp] << [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a << b);"},{"name":"INTSHR","args":[],"desc":"Pop 2 values and push [sp] >> [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a >> b);"},{"name":"UINTSHR","args":[],"desc":"Pop 2 values and push [sp] >> [sp + 1]","c_impl":"ssmUptr a = ssmVal2Uint(reg.sp[0]);\nssmUptr b = ssmVal2Uint(reg.sp[1]);\n*(++reg.sp) = ssmUint2Val(a >> b);"},{"name":"INTAND","args":[],"desc":"Pop 2 values and push [sp] & [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a & b);"},{"name":"INTOR","args":[],"desc":"Pop 2 values and push [sp] | [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a | b);"},{"name":"INTXOR","args":[],"desc":"Pop 2 values and push [sp] ^ [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a ^ b);"},{"name":"INTNEG","args":[],"desc":"Pop 1 value and push ~[sp]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\n*reg.sp = ssmInt2Val(~a);"},{"name":"INTLT","args":[],"desc":"Pop 2 values and push [sp] < [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a < b);"},{"name":"INTLE","args":[],"desc":"Pop 2 values and push [sp] <= [sp + 1]","c_impl":"ssmIptr a = ssmVal2Int(reg.sp[0]);\nssmIptr b = ssmVal2Int(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a <= b);"},{"name":"FLOATADD","args":[],"desc":"Pop 2 values and push [sp] + [sp + 1]","c_impl":"ssmFptr a = ssmVal2Flt(reg.sp[0]);\nssmFptr b = ssmVal2Flt(reg.sp[1]);\n*(++reg.sp) = ssmFlt2Val(a + b);"},{"name":"FLOATSUB","args":[],"desc":"Pop 2 values and push [sp] - [sp + 1]","c_impl":"ssmFptr a = ssmVal2Flt(reg.sp[0]);\nssmFptr b = ssmVal2Flt(reg.sp[1]);\n*(++reg.sp) = ssmFlt2Val(a - b);"},{"name":"FLOATMUL","args":[],"desc":"Pop 2 values and push [sp] * [sp + 1]","c_impl":"ssmFptr a = ssmVal2Flt(reg.sp[0]);\nssmFptr b = ssmVal2Flt(reg.sp[1]);\n*(++reg.sp) = ssmFlt2Val(a * b);"},{"name":"FLOATDIV","args":[],"desc":"Pop 2 values and push [sp] / [sp + 1]","c_impl":"ssmFptr a = ssmVal2Flt(reg.sp[0]);\nssmFptr b = ssmVal2Flt(reg.sp[1]);\n*(++reg.sp) = ssmFlt2Val(a / b);"},{"name":"FLOATUNM","args":[],"desc":"Pop 1 value and push -[sp]","c_impl":"ssmFptr a = ssmVal2Flt(reg.sp[0]);\n*reg.sp = ssmFlt2Val(-a);"},{"name":"FLOATLT","args":[],"desc":"Pop 2 values and push [sp] < [sp + 1]","c_impl":"ssmFptr a = ssmVal2Flt(reg.sp[0]);\nssmFptr b = ssmVal2Flt(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a < b);"},{"name":"FLOATLE","args":[],"desc":"Pop 2 values and push [sp] <= [sp + 1]","c_impl":"ssmFptr a = ssmVal2Flt(reg.sp[0]);\nssmFptr b = ssmVal2Flt(reg.sp[1]);\n*(++reg.sp) = ssmInt2Val(a <= b);"},{"name":"EQ","args":[],"desc":"Pop 2 values and push [sp] == [sp + 1]","c_impl":"int cmp = ssmVal2Uint(reg.sp[0]) == ssmVal2Uint(reg.sp[1]);\nreg.sp++;\n*reg.sp = ssmInt2Val(cmp);"},{"name":"NE","args":[],"desc":"Pop 2 values and push [sp] != [sp + 1]","c_impl":"int cmp = ssmVal2Uint(reg.sp[0]) != ssmVal2Uint(reg.sp[1]);\nreg.sp++;\n*reg.sp = ssmInt2Val(cmp);"},{"name":"JMP","args":[{"name":"off","type":"o32"}],"desc":"Jump to (ip + off)"},{"name":"BEZ","args":[{"name":"off","type":"o16"}],"desc":"Pop 1 value and jump to (ip + off) if [sp] == 0"},{"name":"BNE","args":[{"name":"off","type":"o16"}],"desc":"Pop 1 value and jump to (ip + off) if [sp] != 0"},{"name":"BTAG","args":[{"name":"tag","type":"u16"},{"name":"off","type":"o16"}],"desc":"If the tag of [sp] is tag, jump to (ip + off)"},{"name":"JTAG","args":[{"name":"jmps","type":"j32"}],"desc":"Jump to (ip + jump_table[tag of [sp]])"},{"name":"MAGIC","args":[{"name":"magic","type":"m16"}],"desc":"Invoke magic"},{"name":"XFN","aligned":"left","args":[{"name":"argc","type":"u16"},{"name":"stack_size","type":"u16"}],"desc":"Function header. Argc is the number of arguments, stack size is the maximum size need to run functions. Note that ip of xfn must be aligned by 2."},{"name":"HEADER","args":[{"name":"version","type":"u32"},{"name":"chunk_size","type":"u32"},{"name":"global_offset","type":"u32"},{"name":"global_count","type":"u32"}],"desc":"Chunk header. Only one header is allowed & required for each chunk, and it must be the first instruction. When the chunk is loaded, check the correctness using arguments. When the chunk is executed, the header is ignored and push ip=0 as a return address. When program return to this header, VM will be halted."}],"magics":[{"name":"NOP","desc":"No operation","c_impl":"// Do Nothing"},{"name":"PTOP","desc":"Print the top of the stack","c_impl":"ssmV val = *reg.sp;\nif(ssmIsLiteral(val)) {\n  printf(\"PTOP: Literal 0x%zx (int=%zd, uint=%zu, flt=%f)\\n\",\n    val, ssmVal2Int(val), ssmVal2Uint(val), (float)ssmVal2Flt(val));\n} else {\n  ssmT t = ssmVal2Tup(val);\n  ssmV hd = ssmTHd(t);\n  if(ssmHdIsLong(hd)) {\n    printf(\"PTOP: Long 0x%zx (bytes = %zu)\\n      `%.*s`\", val, ssmHdLongBytes(hd), (int)ssmHdLongBytes(hd), &ssmTByte(t, 0));\n  } else {\n    printf(\"PTOP: Short 0x%zx (words = %zu, tag = %zu)\\n\", val, ssmHdShortWords(hd), ssmHdTag(hd));\n    ssmUptr i;\n    for(i = 0; i < ssmHdShortWords(hd); i++) {\n      printf(\"      [%zu] = 0x%zx\\n\", i, ssmTElem(t, i));\n    }\n  }\n}"},{"name":"HALT","desc":"Pop a VM and halt it"},{"name":"NEWVM","desc":"Push a new VM"},{"name":"NEWPROCESS","desc":"Push a new VM in a new thread/process"},{"name":"VMSELF","desc":"Push current VM"},{"name":"VMPARENT","desc":"Push parent VM"},{"name":"DUP","desc":"Duplicate VM and process. Push each other VM."},{"name":"GLOBALC","desc":"Pop a VM and push the global count of the VM"},{"name":"EXECUTE","desc":"Pop a bytes value, pop a VM and execute the bytes in the VM"},{"name":"HALTED","desc":"Pop a VM and push true if it is halted"},{"name":"SENDMSG","desc":"Pop a message, pop a VM and send the message to the VM"},{"name":"HASMSG","desc":"Push true if there is a message in the message queue"},{"name":"RECVMSG","desc":"Push the message in the message queue. If there is no message, pend"},{"name":"EVAL","desc":"Pop the bytecodes and run it. After running the bytecodes, push the result and return to the original position"},{"name":"FOPEN","desc":"Pop a string and open the file. Push the file handle"},{"name":"FCLOSE","desc":"Pop a file handle and close the file"},{"name":"FFLUSH","desc":"Pop a file handle and flush the file"},{"name":"FREAD","desc":"Pop a file handle and read the file. Push the bytes"},{"name":"FWRITE","desc":"Pop a bytes value, pop a file handle and write the bytes to the file"},{"name":"FTELL","desc":"Pop a file handle and push the current position of the file"},{"name":"FSEEK","desc":"Pop a file handle, pop a position and seek the file to the position"},{"name":"FEOF","desc":"Pop a file handle and push true if the file is at the end"},{"name":"STDREAD","desc":"Read from stdin. Push the bytes"},{"name":"STDWRITE","desc":"Pop a bytes value and write to stdout"},{"name":"STDERROR","desc":"Pop a bytes value and write to stderr"},{"name":"REMOVE","desc":"Pop a string and remove the file"},{"name":"RENAME","desc":"Pop a string, pop a string and rename the file"},{"name":"TMPFILE","desc":"Push a file handle of a temporary file"},{"name":"READFILE","desc":"Pop a string and read the file. Push the bytes"},{"name":"WRITEFILE","desc":"Pop a bytes value, pop a string and write the bytes to the file"},{"name":"MALLOC","desc":"Pop a size and allocate memory. Push the pointer"},{"name":"FREE","desc":"Pop a pointer and free the memory"},{"name":"SRAND","desc":"Pop a seed and set the seed of the random number generator"},{"name":"RAND","desc":"Push a random number"},{"name":"ARG","desc":"Push the argument of the VM"},{"name":"ENV","desc":"Pop a string and push the environment variable"},{"name":"EXIT","desc":"Pop a status and exit the VM","c_impl":"exit(ssmVal2Int(reg.sp[0]));"},{"name":"SYSTEM","desc":"Pop a string and execute the command","c_impl":"ssmT lng = ssmVal2Tup(reg.sp[0]);\nssmV hd = ssmTHd(lng);\nsize_t len = ssmHdLongBytes(hd);\nchar *buf = malloc(len + 1);\nmemcpy(buf, &ssmTByte(lng, 0), len);\nbuf[len] = 0;\nint result = system(buf);\nfree(buf);\nreg.sp[0] = ssmInt2Val(result);"},{"name":"PI","desc":"Push PI","c_impl":"*(++reg.sp) = ssmFlt2Val(3.14159265358979323846);"},{"name":"E","desc":"Push E","c_impl":"*(++reg.sp) = ssmFlt2Val(2.7182818284590452354);"},{"name":"ABS","desc":"Pop a value and push the absolute value","c_impl":"reg.sp[0] = fabs(ssmVal2Flt(reg.sp[0]));"},{"name":"SIN","desc":"Pop a value and push the sine value","c_impl":"reg.sp[0] = sin(ssmVal2Flt(reg.sp[0]));"},{"name":"COS","desc":"Pop a value and push the cosine value","c_impl":"reg.sp[0] = cos(ssmVal2Flt(reg.sp[0]));"},{"name":"TAN","desc":"Pop a value and push the tangent value","c_impl":"reg.sp[0] = tan(ssmVal2Flt(reg.sp[0]));"},{"name":"ASIN","desc":"Pop a value and push the arc sine value","c_impl":"reg.sp[0] = asin(ssmVal2Flt(reg.sp[0]));"},{"name":"ACOS","desc":"Pop a value and push the arc cosine value","c_impl":"reg.sp[0] = acos(ssmVal2Flt(reg.sp[0]));"},{"name":"ATAN","desc":"Pop a value and push the arc tangent value","c_impl":"reg.sp[0] = atan(ssmVal2Flt(reg.sp[0]));"},{"name":"ATAN2","desc":"Pop a value, pop a value and push the arc tangent value"},{"name":"EXP","desc":"Pop a value and push the exponential value","c_impl":"reg.sp[0] = exp(ssmVal2Flt(reg.sp[0]));"},{"name":"LOG","desc":"Pop a value and push the natural logarithm value","c_impl":"reg.sp[0] = log(ssmVal2Flt(reg.sp[0]));"},{"name":"LOG10","desc":"Pop a value and push the base 10 logarithm value","c_impl":"reg.sp[0] = log10(ssmVal2Flt(reg.sp[0]));"},{"name":"MODF","desc":"Pop a value and push the fractional part and the integer part"},{"name":"POW","desc":"Pop a value, pop a value and push the power value"},{"name":"SQRT","desc":"Pop a value and push the square root value"},{"name":"CEIL","desc":"Pop a value and push the ceiling value"},{"name":"FLOOR","desc":"Pop a value and push the floor value"},{"name":"FABS","desc":"Pop a value and push the absolute value"},{"name":"FMOD","desc":"Pop a value, pop a value and push the remainder value"},{"name":"CLOCK","desc":"Push the clock value"},{"name":"TIME","desc":"Push the time value"},{"name":"CWD","desc":"Push the current working directory"},{"name":"ISDIR","desc":"Pop a string and push true if the path is a directory"},{"name":"ISFILE","desc":"Pop a string and push true if the path is a file"},{"name":"MKDIR","desc":"Pop a string and make a directory"},{"name":"RMDIR","desc":"Pop a string and remove a directory"},{"name":"CHDIR","desc":"Pop a string and change the current working directory"},{"name":"FILES","desc":"Pop a string and push the files in the directory"},{"name":"JOINPATH","desc":"Pop a string, pop a string and join the paths"},{"name":"FFILOAD","desc":"Pop a string and load the shared library"},{"name":"OS","desc":"Push the OS name"},{"name":"ARCH","desc":"Push the architecture name"},{"name":"ENDIAN","desc":"Push the endianess"},{"name":"VERSION","desc":"Push the version of the VM"}]}
