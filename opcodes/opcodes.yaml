# Opcode List for SSM
# This is a comment line

# Register
# ip: instruction pointer
# sp: stack pointer
# bp: base pointer
# ap: application pointer
#
# Note:
# - [sp .. bp - 1] is stack frame
# - [bp] is a function
# - [bp + 1 .. ap - 1] is a function's arguments
# 

# Types:
# - All types are litte-endian
# - xx is the number of bits
# ixx - signed int (e.g. i16 = 16-bit signed int)
# uxx - unsigned int (e.g. u16 = 16-bit unsigned int)
# fxx - float (e.g. f32 = 32-bit float)
# bxx - Sequence of bytes
#       In assembly it takes the form of string
#       First xx bits for length of string, and the rest bytes for data
#       e.g. b16 "Hello" = (len) 0x05 0x00 (data) 0x48 0x65 0x6c 0x6c 0x6f
# oxx - offset of instruction (e.g. o16 = 16-bit offset)
#       In assembly it takes the form of a label
# jxx_yy - jump table with xx bits length & yy bits offset

# Currently allowed types:
# - i8, i16, i32, i64
# - u8, u16, u32, u64
# - f32, f64
# - b32
# - o16, o32
# - j16_32

# Format
# OP arg1:type arg2:type ...
# OP: [A-Z]+
# argx: [a-z_]+
# type: [a-z][0-9]+

opcodes:
# -- NO OP
- NOP: [] # do nothing

# -- SSM Header/Footer
- HEADER: # code chunk header
  - token: u32
  - prevglobal: u32
  - newglobal: u32
- HALT: [] # halt the program

# -- STACK
- POP: # pop n elements from stack
  - n: u16 
- PUSH: # push [sp + idx]
  - idx: u16
- PUSHBP: # push [bp - idx]
  - idx: u16
- PUSHAP: # push [bp + idx]
  - idx: i16
- POPSET: # set [sp + idx] to [sp]
  - idx: u16

# -- LITERAL
- PUSHI: # push signed int
  - val: i32
- PUSHF: # push float
  - val: f32

# -- FUNCTION
- PUSHFN: # push function pointer
  - fn: o32

# -- GLOBAL
- PUSHGLOBAL: # push global variable
  - idx: u32
- POPSETGLOBAL: # pop and set to global variable
  - idx: u32

# -- TUPLE
- PUSHISLONG: # push islong flag at [idx]
  - idx: u16

# -- SHORT TUPLE
- TUP: # make a new tup using [sp .. sp + len]
  - tag: u16
  - len: u16
- TAG: # make a new tag-only tup without len
  - tag: u8
- PUSHTAG: # push a tag at [idx]
  - idx: u16
- PUSHLEN: # push a short tuple length at [idx]
  - idx: u16
- PUSHELEM: # push an element at [idx] at [jdx]
  - idx: u16
  - jdx: u16

# -- LONG TUPLE
- LONG: # push a long tuple
  - bytes: b32
- PACK: # pack elements into bytes
  - len: u32
- SETBYTE: # set a byte at [idx] at [jdx]
  - idx: u16
  - jdx: u16
- PUSHLONGLEN: # push a long tuple length at [idx]
  - idx: u16
- PUSHBYTE: # push a byte at [idx]
  - idx: u16
- JOIN: [] # join long tuple elements in a short tuple
- SUBLONG: [] # push a subtuple of a long tuple
- LONGCMP: [] # compare two long tuples

# -- CALL
- APP: # call function at [bp]
  - argc: u16
- RET: # return from function
  - idx: u16
- RETAPP: # tail call function at [bp]
  - argc: u16

# -- INT ARITHMETIC
- INTADD: [] # add two elements on top of stack
- INTSUB: [] # subtract two elements on top of stack
- INTMUL: [] # multiply two elements on top of stack
- UINTMUL: [] # multiply two elements on top of stack
- INTDIV: [] # divide two elements on top of stack
- UINTDIV: [] # divide two elements on top of stack
- INTMOD: [] # modulo two elements on top of stack
- UINTMOD: [] # modulo two elements on top of stack
- INTUNM: [] # unary minus

- INTSHL: [] # shift left two elements on top of stack
- INTSHR: [] # shift right two elements on top of stack
- UINTSHR: [] # shift right arithmetic two elements on top of stack
- INTAND: [] # bitwise and two elements on top of stack
- INTOR: [] # bitwise or two elements on top of stack
- INTXOR: [] # bitwise xor two elements on top of stack
- INTNEG: [] # bitwise not two elements on top of stack

- INTLT: [] # compare two elements on top of stack
- INTLE: [] # compare two elements on top of stack

# -- FLOAT ARITHMETIC
- FLOATADD: [] # add two elements on top of stack
- FLOATSUB: [] # subtract two elements on top of stack
- FLOATMUL: [] # multiply two elements on top of stack
- FLOATDIV: [] # divide two elements on top of stack
- FLOATUNM: [] # unary minus

- FLOATLT: [] # compare two elements on top of stack
- FLOATLE: [] # compare two elements on top of stack

# -- COMPARISON
- EQ: [] # compare two elements on top of stack
- NE: [] # compare two elements on top of stack

# -- BRANCH

- JMP: # jump to offset
  - offset: o32
- BEQ: # branch if not equal
  - offset: o32
- BNE: # branch if not equal
  - offset: o32
- BTAG: # branch if tag is
  - tag: u16
  - offset: o32
- JTAG: # jump table by tag
  - offsets: j16_32

# -- MAGIC
- MAGIC:
  - instr: u16

# -- LITERAL MARKER
- XFN: # function
  - argc: u16
  - stackreq: u32

# ---

# Magic instructions
# Magic instruction is a kind of extension to perform special tasks,
# such as FFI, I/O, OS Features, etc.

magics:

# -- NO OP
- NOP

# -- VM
- NEWVM # create a new VM
- NEWPROCESS # create a new vm process
- VMSELF # push current VM
- VMPARENT # push parent VM
- EVAL # evaluate a bytecode long tuple in vm
- HALTED # check if vm is halted
- SENDMSG # send a message to a vm
- RECVMSG # receive a message from a vm

# -- FILES
- FOPEN # fopen
- FCLOSE # fclose
- FFLUSH # fflush
- FREAD # fread
- FWRITE # fwrite
- FTELL # ftell
- FSEEK # fseek
- FEOF # feof
- STDREAD # read from stdin
- STDWRITE # write to stdout
- STDERROR # write to stderr
- REMOVE # remove file
- RENAME # rename file
- TMPFILE # get a temporary file
- READFILE # read a file into a long tuple
- WRITEFILE # write a long tuple into a file

# -- C STDLIB
- MALLOC # malloc
- FREE # free
- SRAND # srand
- RAND # rand
- ARG # get command line argument
- ENV # get environment variable
- EXIT # exit
- SYSTEM # system

# -- MATH
- PI
- E
- ABS
- SIN
- COS
- TAN
- ASIN
- ACOS
- ATAN
- ATAN2
- EXP
- LOG
- LOG10
- LN
- MODF
- POW
- SQRT
- CEIL
- FLOOR
- FABS
- FMOD

# -- TIME
- CLOCK # get current clock
- TIME # get current time

# -- OS-SPECIFIC FEATURES
- CWD
- ISDIR
- ISFILE
- MKDIR
- RMDIR
- CHDIR
- FILES

# -- FFI
- FFILOAD

