#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

# cgen.rb
# SSM C Code Generator
# Author: lumiknit

require_relative 'spec'
$spec = SSM::spec

# --- File config

$file_header = <<~EOF
  // Generated by /opcode/cgen.rb
  // If this file is modified, please add a comment
EOF

# --- Path Config

script_path = File.dirname(__FILE__)
$root_path = File.expand_path(File.join(script_path, ".."))
$src_path = File.join($root_path, "src")
$include_path = File.join($root_path, "include")

# --- Opcode Header

def gen_opcode_hd
  filename = "ssm_ops"
  path = File.join($include_path, filename + ".h")
  
  ops = []
  $spec.ops.each do |name, o|
    ops << "#define SSM_OP_#{o.name.upcase} ((ssmOp)#{o.index})"
  end

  magics = []
  $spec.magics.each do |name, m|
    magics << "#define SSM_MAGIC_#{m.name.upcase} #{m.index}"
  end

  File.write path, <<~EOF
    #{$file_header}

    #ifndef #{filename.upcase}_H
    #define #{filename.upcase}_H

    #include <stdint.h>

    typedef uint8_t ssmOp;

    #{$spec.ops_arr
      .map{|x| "#define SSM_OP_#{x.name.upcase} ((ssmOp)#{x.index})"}
      .join("\n")}

    typedef uint16_t ssmMagic;
    #{$spec.magic_arr
      .map{|x| "#define SSM_MAGIC_#{x.name.upcase} ((ssmMagic)#{x.index})"}
      .join("\n")}

    #endif
  EOF
end

# --- C Opcode Header Parser
def gen_header
  path = File.join($src_path, "ssm_vm_header.c")

  # Extract name and type and offset
  lst = []
  offset = 1
  $spec.op("header").args.each do |arg|
    lst << {
      name: arg.name,
      ctype: arg.type.type.ctype,
      bytes: arg.type.type.bytes,
      offset: offset
    }
    offset += arg.type.type.bytes
  end
  
  File.write path, <<~EOF
    #{$file_header}

    #include <stdint.h>

    typedef struct OpHeader {
    #{lst
        .map{|a| "  #{a[:ctype]} #{a[:name]};"}
        .join "\n"}
    } OpHeader;

    int readOpHeader(OpHeader *header, const uint8_t *ip) {
      // Check opcode is correct
      if(ip[0] != SSM_OP_HEADER) return 0;
      // Read header
    #{lst
        .map{|a| "  header->#{a[:name]} = read_#{a[:ctype]}(ip + #{a[:offset]});"}
        .join "\n"}
      return #{offset};
    }
  EOF
end

# --- C verify loop
def gen_verify_loop
  path = File.join $src_path, "ssm_vm_verify_loop.c"

  lst = $spec.ops_arr.map do |o|
    open = "case SSM_OP_#{o.name.upcase}: {"
    body = []

    flags = {}

    # Check opcode mark
    case o.name.upcase
    when "XFN"
      body << "mark[i] |= M_X_FN;"
    when "PUSHFN"
      flags[:pushfn] = true
    end

    p = 1
    p_extra = "";
    o.args.each do |arg|
      name = arg.name
      if arg.type.is_a? SSM::ArrayType
        len_type = arg.type.len_type
        elem_type = arg.type.elem_type
        body << "#{len_type.ctype} #{arg.name}_len = read_#{len_type.ctype}(&c->bytes[i + #{p}#{p_extra}]);"
        if elem_type.kind == "offset"
          body << "for(size_t #{arg.name}_i = 0; #{arg.name}_i < #{arg.name}_len; #{arg.name}_i++) {"
          body << "  #{elem_type.ctype} #{arg.name}_elem = read_#{elem_type.ctype}(&c->bytes[i + #{p} + #{arg.name}_i * sizeof(#{elem_type.ctype})#{p_extra}]);"
          body << "  if(i + #{arg.name}_elem < 0 || i + #{arg.name}_elem >= c->size)"
          body << "    goto L_err_offset;"
          body << "  mark[i + #{arg.name}_elem] |= M_JMP_TARGET;"
          body << "}"
        end
        p += len_type.bytes
        p_extra += " + #{arg.name}_len * sizeof(#{elem_type.ctype})"
      elsif arg.type.is_a? SSM::LitType
        type = arg.type.type
        if type.kind == "magic"
          body << "#{type.ctype} #{arg.name} = read_#{type.ctype}(&c->bytes[i + #{p}#{p_extra}]);"
          body << "if(#{arg.name} >= #{$spec.magic_arr.length})"
          body << "  goto L_err_magic;"
        elsif type.kind == "offset"
          body << "#{type.ctype} #{arg.name} = read_#{type.ctype}(&c->bytes[i + #{p}#{p_extra}]);"
          body << "if(i + #{arg.name} < 0 || i + #{arg.name} >= c->size)"
          body << "  goto L_err_offset;"
          if flags[:pushfn]
            body << "mark[i + #{arg.name}] |= M_FN_TARGET;"
          else
            body << "mark[i + #{arg.name}] |= M_JMP_TARGET;"
          end
        elsif type.kind == "global"
          body << "#{type.ctype} #{arg.name} = read_#{type.ctype}(&c->bytes[i + #{p}#{p_extra}]);"
          body << "if(#{arg.name} >= n_globals)"
          body << "  goto L_err_global;"
        end
        type = arg.type.type
        p += type.bytes
      else
        raise "Unknown type: #{arg.type}"
      end
    end
    body << "i += #{p}#{p_extra};"
    close = "} break;"
    ([open] + body.map{|x| "  " + x} + [close]).join "\n"
  end

  File.write path, <<~EOF
    #{$file_header}

    switch(op) {
    #{lst.join("\n")}
    default: goto L_err_op;
    }
  EOF
end

# --- C Jump Table
def gen_opcode_jmptbl
  path = File.join $src_path, "ssm_vm_jmptbl.c"

  File.write path, <<~EOF
    #{$file_header}

    {
    #{$spec.ops_arr
        .map{|x| "  &&L_op_#{x.name.upcase},"}
        .join("\n")}
    }
  EOF
end

# --- C VM Opcode Switch
def gen_opcode_switch
  path = File.join $src_path, "ssm_vm_switch.c"

  lines = $spec.ops_arr.map do |o|
    open = "OP(#{o.name.upcase}): {"
    args = []
    p = 1
    p_extra = "";
    o.args.each do |arg|
      name = arg.name
      if arg.type.is_a? SSM::ArrayType
        len_type = arg.type.len_type
        elem_type = arg.type.elem_type
        args << "#{len_type.ctype} #{arg.name}_len = read_#{len_type.ctype}(ip + #{p}#{p_extra});"
        p += len_type.bytes
        args << "#{elem_type.ctype}* #{arg.name} = (#{elem_type.ctype}*)(ip + #{p}#{p_extra});"
        args << "// Use read_#{elem_type.ctype}(&#{arg.name} + IDX) to get elements"
        p_extra += " + #{arg.name}_len * sizeof(#{elem_type.ctype})"
      elsif arg.type.is_a? SSM::LitType and arg.type.type.kind == "magic"
        # In this case, create switch case
        args << "// Handle magic"
        args << "switch(read_#{arg.type.type.ctype}(ip + #{p}#{p_extra})) {"
        $spec.magics.each do |name, m|
          args << "case SSM_MAGIC_#{m.name.upcase}: {"
          args << "  // #{m.name}"
          args << "  unimplemented();"
          args << "} break;"
        end
        args << "}"
      else
        type = arg.type.type
        args << "#{type.ctype} #{arg.name} = read_#{type.ctype}(ip + #{p}#{p_extra});"
        p += type.bytes
      end
    end
    body = "unimplemented();"
    close = "NEXT(#{p}#{p_extra});\n}"
    open + "\n" + (args + [body, close]).map{|x| "  #{x}"}.join("\n")
  end

  File.write path, <<~EOF
    #{$file_header}

    #{lines.join "\n"}
  EOF
end

# --- CLI

gen_opcode_hd
gen_header
gen_verify_loop
gen_opcode_jmptbl
gen_opcode_switch
