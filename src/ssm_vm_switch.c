// Generated by /opcode/cgen.rb
// If this file is modified, please add a comment


OP(NOP): {
  NEXT(1);
}
OP(POP): {
  uint16_t count = read_uint16_t(reg.ip + 1);
  reg.sp += count;
  NEXT(3);
}
OP(PUSH): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement push
  unimplemented();
  NEXT(3);
}
OP(PUSHBP): {
  uint16_t off_bp = read_uint16_t(reg.ip + 1);
  // TODO: Implement pushbp
  unimplemented();
  NEXT(3);
}
OP(PUSHAP): {
  uint16_t off_ap = read_uint16_t(reg.ip + 1);
  // TODO: Implement pushap
  unimplemented();
  NEXT(3);
}
OP(POPSET): {
  uint16_t off_sp = read_uint16_t(reg.ip + 1);
  // TODO: Implement popset
  unimplemented();
  NEXT(3);
}
OP(PUSHI): {
  int32_t value = read_int32_t(reg.ip + 1);
  // TODO: Implement pushi
  unimplemented();
  NEXT(5);
}
OP(PUSHF): {
  float value = read_float(reg.ip + 1);
  // TODO: Implement pushf
  unimplemented();
  NEXT(5);
}
OP(PUSHFN): {
  int32_t fn_off = read_int32_t(reg.ip + 1);
  // TODO: Implement pushfn
  unimplemented();
  NEXT(5);
}
OP(PUSHGLOBAL): {
  uint32_t global = read_uint32_t(reg.ip + 1);
  // TODO: Implement pushglobal
  unimplemented();
  NEXT(5);
}
OP(POPSETGLOBAL): {
  uint32_t global = read_uint32_t(reg.ip + 1);
  // TODO: Implement popsetglobal
  unimplemented();
  NEXT(5);
}
OP(PUSHISLONG): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement pushislong
  unimplemented();
  NEXT(3);
}
OP(TUP): {
  uint16_t tag = read_uint16_t(reg.ip + 1);
  uint16_t count = read_uint16_t(reg.ip + 3);
  // TODO: Implement tup
  unimplemented();
  NEXT(5);
}
OP(PUSHTAG): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement pushtag
  unimplemented();
  NEXT(3);
}
OP(PUSHLEN): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement pushlen
  unimplemented();
  NEXT(3);
}
OP(PUSHELEM): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  uint16_t index = read_uint16_t(reg.ip + 3);
  // TODO: Implement pushelem
  unimplemented();
  NEXT(5);
}
OP(LONG): {
  uint32_t bytes_len = read_uint32_t(reg.ip + 1);
  uint8_t* bytes = (uint8_t*)(reg.ip + 5);
  // Use read_uint8_t(&bytes + IDX) to get elements
  // TODO: Implement long
  unimplemented();
  NEXT(5 + bytes_len * sizeof(uint8_t));
}
OP(POPSETBYTE): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement popsetbyte
  unimplemented();
  NEXT(3);
}
OP(PUSHLONGLEN): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement pushlonglen
  unimplemented();
  NEXT(3);
}
OP(PUSHBYTE): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement pushbyte
  unimplemented();
  NEXT(3);
}
OP(JOIN): {
  // TODO: Implement join
  unimplemented();
  NEXT(1);
}
OP(SUBLONG): {
  // TODO: Implement sublong
  unimplemented();
  NEXT(1);
}
OP(LONGCMP): {
  // TODO: Implement longcmp
  unimplemented();
  NEXT(1);
}
OP(APP): {
  uint16_t count = read_uint16_t(reg.ip + 1);
  // TODO: Implement app
  unimplemented();
  NEXT(3);
}
OP(RET): {
  uint16_t off = read_uint16_t(reg.ip + 1);
  // TODO: Implement ret
  unimplemented();
  NEXT(3);
}
OP(RETAPP): {
  uint16_t count = read_uint16_t(reg.ip + 1);
  // TODO: Implement retapp
  unimplemented();
  NEXT(3);
}
OP(INTADD): {
  // TODO: Implement intadd
  unimplemented();
  NEXT(1);
}
OP(INTSUB): {
  // TODO: Implement intsub
  unimplemented();
  NEXT(1);
}
OP(INTMUL): {
  // TODO: Implement intmul
  unimplemented();
  NEXT(1);
}
OP(UINTMUL): {
  // TODO: Implement uintmul
  unimplemented();
  NEXT(1);
}
OP(INTDIV): {
  // TODO: Implement intdiv
  unimplemented();
  NEXT(1);
}
OP(UINTDIV): {
  // TODO: Implement uintdiv
  unimplemented();
  NEXT(1);
}
OP(INTMOD): {
  // TODO: Implement intmod
  unimplemented();
  NEXT(1);
}
OP(UINTMOD): {
  // TODO: Implement uintmod
  unimplemented();
  NEXT(1);
}
OP(INTUNM): {
  // TODO: Implement intunm
  unimplemented();
  NEXT(1);
}
OP(INTSHL): {
  // TODO: Implement intshl
  unimplemented();
  NEXT(1);
}
OP(INTSHR): {
  // TODO: Implement intshr
  unimplemented();
  NEXT(1);
}
OP(UINTSHR): {
  // TODO: Implement uintshr
  unimplemented();
  NEXT(1);
}
OP(INTAND): {
  // TODO: Implement intand
  unimplemented();
  NEXT(1);
}
OP(INTOR): {
  // TODO: Implement intor
  unimplemented();
  NEXT(1);
}
OP(INTXOR): {
  // TODO: Implement intxor
  unimplemented();
  NEXT(1);
}
OP(INTNEG): {
  // TODO: Implement intneg
  unimplemented();
  NEXT(1);
}
OP(INTLT): {
  // TODO: Implement intlt
  unimplemented();
  NEXT(1);
}
OP(INTLE): {
  // TODO: Implement intle
  unimplemented();
  NEXT(1);
}
OP(FLOATADD): {
  // TODO: Implement floatadd
  unimplemented();
  NEXT(1);
}
OP(FLOATSUB): {
  // TODO: Implement floatsub
  unimplemented();
  NEXT(1);
}
OP(FLOATMUL): {
  // TODO: Implement floatmul
  unimplemented();
  NEXT(1);
}
OP(FLOATDIV): {
  // TODO: Implement floatdiv
  unimplemented();
  NEXT(1);
}
OP(FLOATUNM): {
  // TODO: Implement floatunm
  unimplemented();
  NEXT(1);
}
OP(FLOATLT): {
  // TODO: Implement floatlt
  unimplemented();
  NEXT(1);
}
OP(FLOATLE): {
  // TODO: Implement floatle
  unimplemented();
  NEXT(1);
}
OP(EQ): {
  // TODO: Implement eq
  unimplemented();
  NEXT(1);
}
OP(NE): {
  // TODO: Implement ne
  unimplemented();
  NEXT(1);
}
OP(JMP): {
  int32_t off = read_int32_t(reg.ip + 1);
  // TODO: Implement jmp
  unimplemented();
  NEXT(5);
}
OP(BEZ): {
  int16_t off = read_int16_t(reg.ip + 1);
  // TODO: Implement bez
  unimplemented();
  NEXT(3);
}
OP(BNE): {
  int16_t off = read_int16_t(reg.ip + 1);
  // TODO: Implement bne
  unimplemented();
  NEXT(3);
}
OP(BTAG): {
  uint16_t tag = read_uint16_t(reg.ip + 1);
  int16_t off = read_int16_t(reg.ip + 3);
  // TODO: Implement btag
  unimplemented();
  NEXT(5);
}
OP(JTAG): {
  uint32_t jump_table_len = read_uint32_t(reg.ip + 1);
  int32_t* jump_table = (int32_t*)(reg.ip + 5);
  // Use read_int32_t(&jump_table + IDX) to get elements
  // TODO: Implement jtag
  unimplemented();
  NEXT(5 + jump_table_len * sizeof(int32_t));
}
OP(MAGIC): {
  // Handle magic
  switch(read_uint16_t(reg.ip + 1)) {
  case SSM_MAGIC_NOP: {
    // nop
    unimplemented();
  } break;
  case SSM_MAGIC_HALT: {
    // halt
    unimplemented();
  } break;
  case SSM_MAGIC_NEWVM: {
    // newvm
    unimplemented();
  } break;
  case SSM_MAGIC_NEWPROCESS: {
    // newprocess
    unimplemented();
  } break;
  case SSM_MAGIC_VMSELF: {
    // vmself
    unimplemented();
  } break;
  case SSM_MAGIC_VMPARENT: {
    // vmparent
    unimplemented();
  } break;
  case SSM_MAGIC_DUP: {
    // dup
    unimplemented();
  } break;
  case SSM_MAGIC_GLOBALC: {
    // globalc
    unimplemented();
  } break;
  case SSM_MAGIC_EXECUTE: {
    // execute
    unimplemented();
  } break;
  case SSM_MAGIC_HALTED: {
    // halted
    unimplemented();
  } break;
  case SSM_MAGIC_SENDMSG: {
    // sendmsg
    unimplemented();
  } break;
  case SSM_MAGIC_HASMSG: {
    // hasmsg
    unimplemented();
  } break;
  case SSM_MAGIC_RECVMSG: {
    // recvmsg
    unimplemented();
  } break;
  case SSM_MAGIC_EVAL: {
    // eval
    unimplemented();
  } break;
  case SSM_MAGIC_FOPEN: {
    // fopen
    unimplemented();
  } break;
  case SSM_MAGIC_FCLOSE: {
    // fclose
    unimplemented();
  } break;
  case SSM_MAGIC_FFLUSH: {
    // fflush
    unimplemented();
  } break;
  case SSM_MAGIC_FREAD: {
    // fread
    unimplemented();
  } break;
  case SSM_MAGIC_FWRITE: {
    // fwrite
    unimplemented();
  } break;
  case SSM_MAGIC_FTELL: {
    // ftell
    unimplemented();
  } break;
  case SSM_MAGIC_FSEEK: {
    // fseek
    unimplemented();
  } break;
  case SSM_MAGIC_FEOF: {
    // feof
    unimplemented();
  } break;
  case SSM_MAGIC_STDREAD: {
    // stdread
    unimplemented();
  } break;
  case SSM_MAGIC_STDWRITE: {
    // stdwrite
    unimplemented();
  } break;
  case SSM_MAGIC_STDERROR: {
    // stderror
    unimplemented();
  } break;
  case SSM_MAGIC_REMOVE: {
    // remove
    unimplemented();
  } break;
  case SSM_MAGIC_RENAME: {
    // rename
    unimplemented();
  } break;
  case SSM_MAGIC_TMPFILE: {
    // tmpfile
    unimplemented();
  } break;
  case SSM_MAGIC_READFILE: {
    // readfile
    unimplemented();
  } break;
  case SSM_MAGIC_WRITEFILE: {
    // writefile
    unimplemented();
  } break;
  case SSM_MAGIC_MALLOC: {
    // malloc
    unimplemented();
  } break;
  case SSM_MAGIC_FREE: {
    // free
    unimplemented();
  } break;
  case SSM_MAGIC_SRAND: {
    // srand
    unimplemented();
  } break;
  case SSM_MAGIC_RAND: {
    // rand
    unimplemented();
  } break;
  case SSM_MAGIC_ARG: {
    // arg
    unimplemented();
  } break;
  case SSM_MAGIC_ENV: {
    // env
    unimplemented();
  } break;
  case SSM_MAGIC_EXIT: {
    // exit
    unimplemented();
  } break;
  case SSM_MAGIC_SYSTEM: {
    // system
    unimplemented();
  } break;
  case SSM_MAGIC_PI: {
    // pi
    unimplemented();
  } break;
  case SSM_MAGIC_E: {
    // e
    unimplemented();
  } break;
  case SSM_MAGIC_ABS: {
    // abs
    unimplemented();
  } break;
  case SSM_MAGIC_SIN: {
    // sin
    unimplemented();
  } break;
  case SSM_MAGIC_COS: {
    // cos
    unimplemented();
  } break;
  case SSM_MAGIC_TAN: {
    // tan
    unimplemented();
  } break;
  case SSM_MAGIC_ASIN: {
    // asin
    unimplemented();
  } break;
  case SSM_MAGIC_ACOS: {
    // acos
    unimplemented();
  } break;
  case SSM_MAGIC_ATAN: {
    // atan
    unimplemented();
  } break;
  case SSM_MAGIC_ATAN2: {
    // atan2
    unimplemented();
  } break;
  case SSM_MAGIC_EXP: {
    // exp
    unimplemented();
  } break;
  case SSM_MAGIC_LOG: {
    // log
    unimplemented();
  } break;
  case SSM_MAGIC_LOG10: {
    // log10
    unimplemented();
  } break;
  case SSM_MAGIC_LN: {
    // ln
    unimplemented();
  } break;
  case SSM_MAGIC_MODF: {
    // modf
    unimplemented();
  } break;
  case SSM_MAGIC_POW: {
    // pow
    unimplemented();
  } break;
  case SSM_MAGIC_SQRT: {
    // sqrt
    unimplemented();
  } break;
  case SSM_MAGIC_CEIL: {
    // ceil
    unimplemented();
  } break;
  case SSM_MAGIC_FLOOR: {
    // floor
    unimplemented();
  } break;
  case SSM_MAGIC_FABS: {
    // fabs
    unimplemented();
  } break;
  case SSM_MAGIC_FMOD: {
    // fmod
    unimplemented();
  } break;
  case SSM_MAGIC_CLOCK: {
    // clock
    unimplemented();
  } break;
  case SSM_MAGIC_TIME: {
    // time
    unimplemented();
  } break;
  case SSM_MAGIC_CWD: {
    // cwd
    unimplemented();
  } break;
  case SSM_MAGIC_ISDIR: {
    // isdir
    unimplemented();
  } break;
  case SSM_MAGIC_ISFILE: {
    // isfile
    unimplemented();
  } break;
  case SSM_MAGIC_MKDIR: {
    // mkdir
    unimplemented();
  } break;
  case SSM_MAGIC_RMDIR: {
    // rmdir
    unimplemented();
  } break;
  case SSM_MAGIC_CHDIR: {
    // chdir
    unimplemented();
  } break;
  case SSM_MAGIC_FILES: {
    // files
    unimplemented();
  } break;
  case SSM_MAGIC_JOINPATH: {
    // joinpath
    unimplemented();
  } break;
  case SSM_MAGIC_FFILOAD: {
    // ffiload
    unimplemented();
  } break;
  case SSM_MAGIC_OS: {
    // os
    unimplemented();
  } break;
  case SSM_MAGIC_ARCH: {
    // arch
    unimplemented();
  } break;
  case SSM_MAGIC_ENDIAN: {
    // endian
    unimplemented();
  } break;
  case SSM_MAGIC_VERSION: {
    // version
    unimplemented();
  } break;
  }
  // TODO: Implement magic
  unimplemented();
  NEXT(1);
}
OP(XFN): {
  uint16_t argc = read_uint16_t(reg.ip + 1);
  uint16_t stack_size = read_uint16_t(reg.ip + 3);
  // TODO: Implement xfn
  unimplemented();
  NEXT(5);
}
OP(HEADER): {
  uint32_t version = read_uint32_t(reg.ip + 1);
  uint32_t chunk_size = read_uint32_t(reg.ip + 5);
  uint32_t global_offset = read_uint32_t(reg.ip + 9);
  uint32_t global_count = read_uint32_t(reg.ip + 13);
  // TODO: Implement header
  unimplemented();
  NEXT(17);
}
