/**
 * @file ssm_vm.c
 * @author lumiknit (aasr4r4@gmail.com)
 * @copyright Copyright (c) 2023 lumiknit
 * @copyright This file is part of ssm.
 */

#include <ssm.h>
#include <ssm_i.h>

typedef struct Code {
  struct Code *next;
  size_t n_code;
  ssmOp code[1];
} Code;

void ssmLoadDefaultConfig(ssmConfig* config) {
  // 100%
  config->major_gc_threshold_percent = 100;
  // <= 1MB
  config->minor_heap_size = (2 << 20) >> 3;
  // <= 1MB
  config->initial_stack_size = (2 << 20) >> 3;
  config->initial_global_size = 128;
}

void ssmInitVM(ssmVM* vm, ssmConfig* config) {
  ssmInitMem(
    &vm->mem,
    config->minor_heap_size,
    config->major_gc_threshold_percent,
    config->initial_stack_size,
    config->initial_global_size);

  vm->code = NULL;
  vm->n_code = 1024;
}

void ssmFiniVM(ssmVM* vm) {
  // Free all codes
  Code *c = vm->code;
  while(c != NULL) {
    Code *next = c->next;
    free(c);
    c = next;
  }

  ssmFiniMem(&vm->mem);
}

int ssmLoadFile(ssmVM *vm, const char *filename) {
  // Read file
  FILE *file = fopen(filename, "rb");
  if (file == NULL) {
    return -1;
  }
  fseek(file, 0, SEEK_END);
  size_t size = ftell(file);
  rewind(file);

  // Allocate code
  Code *c = malloc(sizeof(Code) + size);
  c->next = vm->code;
  c->n_code = size;
  fread(c->code, 1, size, file);
  vm->code = (void*) c;

  // Run VM
  ssmRunVM(vm, (ssmOp*) &c->code);
  return 0;
}

int ssmLoadCode(ssmVM *vm, const ssmOp *code, size_t n_code) {
  // Allocate code
  Code *c = malloc(sizeof(Code) + n_code);
  c->next = vm->code;
  c->n_code = n_code;
  memncpy(c->code, code, n_code);
  vm->code = (void*) c;

  // Run VM
  ssmRunVM(vm, (ssmOp*) &c->code);
  return 0;
}

#define THREADED_CODE

// --- VM Interpreter BEGIN ---
void ssmRunVM(ssmVM* vm, ssmV entry_ip) {
  ssmOp *ip = vm->code + entry_ip;

  // Initialize macros
#ifdef THREADED_CODE
  #define OP(op) L_op_##op
  #define NEXT(n) goto *jump_table[*(ip += n)]
#else
  #define OP(op) case op
  #define NEXT(n) ip += n; break;
#endif

#ifdef THREADED_CODE
  static void *jump_table[] = {
    // Generated by opcode-rs
    &&L_op_NOP,
    &&L_op_POP,
    &&L_op_PUSH,
    &&L_op_PUSHBP,
    &&L_op_PUSHAP,
    &&L_op_POPSET,
    &&L_op_PUSHI,
    &&L_op_PUSHF,
    &&L_op_PUSHFN,
    &&L_op_PUSHGLOBAL,
    &&L_op_POPSETGLOBAL,
    &&L_op_PUSHISLONG,
    &&L_op_TUP,
    &&L_op_TAG,
    &&L_op_PUSHTAG,
    &&L_op_PUSHLEN,
    &&L_op_PUSHELEM,
    &&L_op_LONG,
    &&L_op_PACK,
    &&L_op_SETBYTE,
    &&L_op_PUSHLONGLEN,
    &&L_op_PUSHBYTE,
    &&L_op_JOIN,
    &&L_op_SUBLONG,
    &&L_op_LONGCMP,
    &&L_op_APP,
    &&L_op_RET,
    &&L_op_RETAPP,
    &&L_op_INTADD,
    &&L_op_INTSUB,
    &&L_op_INTMUL,
    &&L_op_UINTMUL,
    &&L_op_INTDIV,
    &&L_op_UINTDIV,
    &&L_op_INTMOD,
    &&L_op_UINTMOD,
    &&L_op_INTUNM,
    &&L_op_INTSHL,
    &&L_op_INTSHR,
    &&L_op_UINTSHR,
    &&L_op_INTAND,
    &&L_op_INTOR,
    &&L_op_INTXOR,
    &&L_op_INTNEG,
    &&L_op_INTLT,
    &&L_op_INTLE,
    &&L_op_FLOATADD,
    &&L_op_FLOATSUB,
    &&L_op_FLOATMUL,
    &&L_op_FLOATDIV,
    &&L_op_FLOATUNM,
    &&L_op_FLOATLT,
    &&L_op_FLOATLE,
    &&L_op_EQ,
    &&L_op_NE,
    &&L_op_JMP,
    &&L_op_BEQ,
    &&L_op_BNE,
    &&L_op_BTAG,
    &&L_op_JTAG,
    &&L_op_MAGIC,
    &&L_op_XFN,
    &&L_op_HEADER,
    &&L_op_HALT,
  };
  NEXT(0);
#else
  for(;;) { switch(*ip) {
#endif

    // Generated by opcode-rs
    OP(NOP): {
    } NEXT(1);
    OP(POP): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(PUSH): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(PUSHBP): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(PUSHAP): {
      int16_t a0 = SSM_READ_I16(ip + 1);
    } NEXT(3);
    OP(POPSET): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(PUSHI): {
      int32_t a0 = SSM_READ_I32(ip + 1);
    } NEXT(5);
    OP(PUSHF): {
      float a0 = SSM_READ_F32(ip + 1);
    } NEXT(5);
    OP(PUSHFN): {
      int32_t a0 = SSM_READ_I32(ip + 1);
    } NEXT(5);
    OP(PUSHGLOBAL): {
      uint32_t a0 = SSM_READ_U32(ip + 1);
    } NEXT(5);
    OP(POPSETGLOBAL): {
      uint32_t a0 = SSM_READ_U32(ip + 1);
    } NEXT(5);
    OP(PUSHISLONG): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(TUP): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
      uint16_t a1 = SSM_READ_U16(ip + 3);
    } NEXT(5);
    OP(TAG): {
      uint8_t a0 = SSM_READ_U8(ip + 1);
    } NEXT(2);
    OP(PUSHTAG): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(PUSHLEN): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(PUSHELEM): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
      uint16_t a1 = SSM_READ_U16(ip + 3);
    } NEXT(5);
    OP(LONG): {
    } NEXT(1);
    OP(PACK): {
      uint32_t a0 = SSM_READ_U32(ip + 1);
    } NEXT(5);
    OP(SETBYTE): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
      uint16_t a1 = SSM_READ_U16(ip + 3);
    } NEXT(5);
    OP(PUSHLONGLEN): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(PUSHBYTE): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(JOIN): {
    } NEXT(1);
    OP(SUBLONG): {
    } NEXT(1);
    OP(LONGCMP): {
    } NEXT(1);
    OP(APP): {
      uint32_t a0 = SSM_READ_U32(ip + 1);
    } NEXT(5);
    OP(RET): {
      uint32_t a0 = SSM_READ_U32(ip + 1);
    } NEXT(5);
    OP(RETAPP): {
      uint32_t a0 = SSM_READ_U32(ip + 1);
    } NEXT(5);
    OP(INTADD): {
    } NEXT(1);
    OP(INTSUB): {
    } NEXT(1);
    OP(INTMUL): {
    } NEXT(1);
    OP(UINTMUL): {
    } NEXT(1);
    OP(INTDIV): {
    } NEXT(1);
    OP(UINTDIV): {
    } NEXT(1);
    OP(INTMOD): {
    } NEXT(1);
    OP(UINTMOD): {
    } NEXT(1);
    OP(INTUNM): {
    } NEXT(1);
    OP(INTSHL): {
    } NEXT(1);
    OP(INTSHR): {
    } NEXT(1);
    OP(UINTSHR): {
    } NEXT(1);
    OP(INTAND): {
    } NEXT(1);
    OP(INTOR): {
    } NEXT(1);
    OP(INTXOR): {
    } NEXT(1);
    OP(INTNEG): {
    } NEXT(1);
    OP(INTLT): {
    } NEXT(1);
    OP(INTLE): {
    } NEXT(1);
    OP(FLOATADD): {
    } NEXT(1);
    OP(FLOATSUB): {
    } NEXT(1);
    OP(FLOATMUL): {
    } NEXT(1);
    OP(FLOATDIV): {
    } NEXT(1);
    OP(FLOATUNM): {
    } NEXT(1);
    OP(FLOATLT): {
    } NEXT(1);
    OP(FLOATLE): {
    } NEXT(1);
    OP(EQ): {
    } NEXT(1);
    OP(NE): {
    } NEXT(1);
    OP(JMP): {
      int32_t a0 = SSM_READ_I32(ip + 1);
    } NEXT(5);
    OP(BEQ): {
      int32_t a0 = SSM_READ_I32(ip + 1);
    } NEXT(5);
    OP(BNE): {
      int32_t a0 = SSM_READ_I32(ip + 1);
    } NEXT(5);
    OP(BTAG): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
      int32_t a1 = SSM_READ_I32(ip + 3);
    } NEXT(7);
    OP(JTAG): {
    } NEXT(1);
    OP(MAGIC): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
    } NEXT(3);
    OP(XFN): {
      uint16_t a0 = SSM_READ_U16(ip + 1);
      uint32_t a1 = SSM_READ_U32(ip + 3);
    } NEXT(7);
    OP(HEADER): {
      uint32_t a0 = SSM_READ_U32(ip + 1);
      uint32_t a1 = SSM_READ_U32(ip + 5);
      uint32_t a2 = SSM_READ_U32(ip + 9);
    } NEXT(13);
    OP(HALT): {
    } NEXT(1);
    
#ifdef THREADED_CODE
#else
  } }
#endif
}
// --- VM Interpreter END ---
